#!/usr/bin/env bash

display_logo() {
    YELLOW='\033[1;33m'
    NC='\033[0m'
    echo -e "${YELLOW}
█ █ █ █ █▄ █ ▀█▀ █▀█ █▀▀ █▀▀ █   █▀▀
▀▄▀▄▀ █ █ ▀█  █  █▄█ █▄█ █▄█ █▄▄ ██▄
    ${NC}"
}

VERSION="0.1.2"

cmd=""
window_name=""
on_activate=""
on_minimize=""
display_help() {
    echo "Toggle a window in or out of the current active monitor."
    echo
    echo "Usage:"
    echo "    wintoggle [options]"
    echo "Options:"
    echo "    -n, --name                       The window process name to toggle as searchable by pgrep."
    echo "    -a, --on-activate                Run this command on activate of window."
    echo "    -m, --on-minimize                Run this command on minimize of window."
    echo "    -c, --cmd                        The command to execute that opens new window when its not running if different from window process name."
    echo "    -v, --version                    Display version information."
    echo "    -h, --help                       Display command help."
}

if [ $# -eq 0 ]; then
    display_logo
    display_help
    exit 0
fi

while [ $# -gt 0 ]; do
    case "$1" in
    --cmd | -c)
        cmd="$2"
        shift
        ;;
    --on-minimize | -m)
        on_minimize="$2"
        shift
        ;;
    --on-activate | -a)
        on_activate="$2"
        shift
        ;;
    --name | -n)
        window_name="$(echo $2 | xargs)"
        shift
        ;;
    --version | -v)
        echo "v$VERSION"
        exit 0
        ;;
    -h | --help)
        display_logo
        display_help
        exit 0
        ;;
    *)
        echo "Unknown argument or option: $1 (use --option value format)"
        exit 1
        ;;
    esac
    shift
done

if [[ -z "$window_name" ]]; then
    echo "❌ Error: window name is required via --name option."
    exit 1
fi

get_window_id() {
    local pattern="$1"
    local pid
    pids=$(pgrep "$pattern" 2>/dev/null) # Gets ALL matching processes
    for pid in $pids; do                 # Check each one for a window
        wid=$(wmctrl -lp 2>/dev/null | awk -v pid="$pid" '$3 == pid {print $1; exit}')
        if [[ -n "$wid" ]]; then
            echo "$wid"
            return 0
        fi
    done
}

wait_for_window() {
    local pattern="$1"
    local timeout="${2:-10}"
    local interval="${3:-0.2}"

    local elapsed=0
    local id=""

    while (($(echo "$elapsed < $timeout" | bc -l))); do
        id=$(get_window_id "$pattern")
        if [[ -n "$id" ]]; then
            echo "Found window: Process:$pattern | ID: $id"
            echo "$id"
            return 0
        fi
        echo "Waiting For Window: Process:$pattern | Backoff: $elapsed/$timeout"
        sleep "$interval"
        elapsed=$(echo "$elapsed + $interval" | bc -l)
    done

    echo "Timed out waiting for window: $pattern" >&2
    return 1
}

run_hook() {
    local hook="$1"
    [[ -z "$hook" ]] && return 0
    echo "Running hook: $hook"
    bash -lc "$hook" || {
        echo "Hook failed: $hook" >&2
        return 1
    }
}

# Improved focus function with better X11 handling
focus_window() {
    local wid="$1"
    eval $(xdotool getmouselocation --shell)

    if [[ $(xdotool get_num_desktops 2>/dev/null) -gt 1 ]]; then
        active_desktop=$(xdotool get_desktop 2>/dev/null)
        xdotool set_desktop_for_window $wid $active_desktop
    fi

    xdotool windowmove "$wid" "$X" "$Y"
    xdotool windowactivate --sync "$wid"
}

# Check for required tools
for tool in xdotool wmctrl xprop pgrep bc; do
    if ! command -v "$tool" >/dev/null 2>&1; then
        echo "❌ Required tool not found: $tool"
        exit 1
    fi
done

# Main logic
window_id="$(get_window_id "$window_name")"

if [[ -z "$window_id" ]]; then
    # Window doesn't exist, start new process
    if [[ -z "$cmd" ]]; then
        cmd="$window_name"
    fi

    if ! command -v "$cmd" >/dev/null 2>&1; then
        echo "❌ Executable not found: $cmd"
        exit 1
    fi

    echo "Starting new process: $cmd"
    run_hook "$on_activate"

    nohup setsid bash -c "$cmd" </dev/null >/dev/null 2>&1 &
    disown

    # Wait for window to appear with shorter timeout for responsiveness
    if wait_for_window "$window_name" 10; then
        echo "New window created successfully"
    fi
    # halt further execution as we just opened a new window
    xdotool getactivewindow --sync 2>/dev/null
    exit 0
fi

echo "Window Process Name: $window_name"
echo "Window ID: $window_id"

state=""
if ! state="$(xprop -id "$window_id" _NET_WM_STATE 2>/dev/null)"; then
    echo "❌ Could not get window state for ID: $window_id"
    exit 1
fi

focused_window=0
if ! focused_window="$(xdotool getactivewindow 2>/dev/null)"; then
    echo "❌ Could not get currently active window ID"
    exit 1
fi

if [[ $focused_window -eq $window_id ]]; then
    has_focus=true
else
    has_focus=false
fi

echo "Window State: $state"
if [[ ${state,,} == *"_net_wm_state_hidden"* ]] || ! $has_focus; then
    echo "Window Action: Activate"
    focus_window "$window_id"
    run_hook "$on_activate"
else
    echo "Window Action: Hide"
    # Use xdotool for minimize (wmctrl doesn't have a minimize option)
    xdotool windowminimize --sync "$window_id" 2>/dev/null
    run_hook "$on_minimize"
fi
